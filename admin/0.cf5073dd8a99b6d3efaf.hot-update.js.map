{"version":3,"file":"0.cf5073dd8a99b6d3efaf.hot-update.js","sources":["webpack:///./src/components/MapNavigation/ImageMapper.js"],"sourcesContent":["import React, { Component } from \"react\"\nimport PropTypes from \"prop-types\"\nimport isEqual from \"react-fast-compare\"\n\n// https://github.com/coldiary/react-image-mapper\n// MIT licensed open source\n// this is an edited version to support alt tags\nexport default class ImageMapper extends Component {\n  constructor(props) {\n    super(props)\n    ;[\n      \"drawrect\",\n      \"drawcircle\",\n      \"drawpoly\",\n      \"initCanvas\",\n      \"renderPrefilledAreas\",\n    ].forEach(f => (this[f] = this[f].bind(this)))\n    let absPos = { position: \"absolute\", top: 0, left: 0 }\n    this.styles = {\n      container: { position: \"relative\", borderColor: \"red\" },\n      canvas: { ...absPos, pointerEvents: \"none\", zIndex: 2 },\n      img: { ...absPos, zIndex: 1, userSelect: \"none\" },\n      map: (props.onClick && { cursor: \"pointer\" }) || undefined,\n    }\n    // Props watched for changes to trigger update\n    this.watchedProps = [\n      \"active\",\n      \"fillColor\",\n      \"height\",\n      \"imgWidth\",\n      \"lineWidth\",\n      \"src\",\n      \"strokeColor\",\n      \"width\",\n    ]\n  }\n\n  shouldComponentUpdate(nextProps) {\n    const propChanged = this.watchedProps.some(\n      prop => this.props[prop] !== nextProps[prop]\n    )\n    return !isEqual(this.props.map, this.state.map) || propChanged\n  }\n\n  componentWillMount() {\n    this.updateCacheMap()\n  }\n\n  updateCacheMap() {\n    this.setState(\n      { map: JSON.parse(JSON.stringify(this.props.map)) },\n      this.initCanvas\n    )\n  }\n\n  componentDidUpdate() {\n    this.updateCacheMap()\n    this.initCanvas()\n  }\n\n  drawrect(coords, fillColor) {\n    let [left, top, right, bot] = coords\n    this.ctx.fillStyle = fillColor\n    this.ctx.strokeRect(left, top, right - left, bot - top)\n    this.ctx.fillRect(left, top, right - left, bot - top)\n    this.ctx.fillStyle = this.props.fillColor\n  }\n\n  drawcircle(coords, fillColor) {\n    this.ctx.fillStyle = fillColor\n    this.ctx.beginPath()\n    this.ctx.arc(coords[0], coords[1], coords[2], 0, 2 * Math.PI)\n    this.ctx.closePath()\n    this.ctx.stroke()\n    this.ctx.fill()\n    this.ctx.fillStyle = this.props.fillColor\n  }\n\n  drawpoly(coords, fillColor) {\n    coords = coords.reduce(\n      (a, v, i, s) => (i % 2 ? a : [...a, s.slice(i, i + 2)]),\n      []\n    )\n    this.ctx.fillStyle = fillColor\n    this.ctx.beginPath()\n    let first = coords.unshift()\n    this.ctx.moveTo(first[0], first[1])\n    coords.forEach(c => this.ctx.lineTo(c[0], c[1]))\n    this.ctx.closePath()\n    this.ctx.stroke()\n    this.ctx.fill()\n    this.ctx.fillStyle = this.props.fillColor\n  }\n\n  initCanvas() {\n    if (this.props.width) this.img.width = this.props.width\n\n    if (this.props.height) this.img.height = this.props.height\n\n    this.canvas.width = this.props.width || this.img.clientWidth\n    this.canvas.height = this.props.height || this.img.clientHeight\n    this.container.style.width =\n      (this.props.width || this.img.clientWidth) + \"px\"\n    this.container.style.height =\n      (this.props.height || this.img.clientHeight) + \"px\"\n    this.ctx = this.canvas.getContext(\"2d\")\n    this.ctx.fillStyle = this.props.fillColor\n    this.ctx.strokeStyle = this.props.strokeColor\n    this.ctx.lineWidth = this.props.lineWidth\n\n    if (this.props.onLoad) this.props.onLoad()\n\n    this.renderPrefilledAreas()\n  }\n\n  hoverOn(area, index, event) {\n    const shape = event.target.getAttribute(\"shape\")\n\n    if (this.props.active && this[\"draw\" + shape])\n      this[\"draw\" + shape](\n        event.target.getAttribute(\"coords\").split(\",\"),\n        area.fillColor\n      )\n\n    if (this.props.onMouseEnter) this.props.onMouseEnter(area, index, event)\n  }\n\n  hoverOff(area, index, event) {\n    if (this.props.active) {\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n      this.renderPrefilledAreas()\n    }\n\n    if (this.props.onMouseLeave) this.props.onMouseLeave(area, index, event)\n  }\n\n  click(area, index, event) {\n    if (this.props.onClick) {\n      event.preventDefault()\n      this.props.onClick(area, index, event)\n    }\n  }\n\n  imageClick(event) {\n    if (this.props.onImageClick) {\n      event.preventDefault()\n      this.props.onImageClick(event)\n    }\n  }\n\n  mouseMove(area, index, event) {\n    if (this.props.onMouseMove) {\n      this.props.onMouseMove(area, index, event)\n    }\n  }\n\n  imageMouseMove(area, index, event) {\n    if (this.props.onImageMouseMove) {\n      this.props.onImageMouseMove(area, index, event)\n    }\n  }\n\n  scaleCoords(coords) {\n    const { imgWidth, width } = this.props\n    // calculate scale based on current 'width' and the original 'imgWidth'\n    const scale = width && imgWidth && imgWidth > 0 ? width / imgWidth : 1\n    return coords.map(coord => coord * scale)\n  }\n\n  renderPrefilledAreas() {\n    this.state.map.areas.map(area => {\n      if (!area.preFillColor) return\n      this[\"draw\" + area.shape](\n        this.scaleCoords(area.coords),\n        area.preFillColor\n      )\n    })\n  }\n\n  computeCenter(area) {\n    if (!area) return [0, 0]\n\n    const scaledCoords = this.scaleCoords(area.coords)\n\n    switch (area.shape) {\n      case \"circle\":\n        return [scaledCoords[0], scaledCoords[1]]\n      case \"poly\":\n      case \"rect\":\n      default: {\n        // Calculate centroid\n        const n = scaledCoords.length / 2\n        const { y, x } = scaledCoords.reduce(\n          ({ y, x }, val, idx) => {\n            return !(idx % 2) ? { y, x: x + val / n } : { y: y + val / n, x }\n          },\n          { y: 0, x: 0 }\n        )\n        return [x, y]\n      }\n    }\n  }\n\n  renderAreas() {\n    return this.state.map.areas.map((area, index) => {\n      const scaledCoords = this.scaleCoords(area.coords)\n      const center = this.computeCenter(area)\n      const extendedArea = { ...area, scaledCoords, center }\n\n      return (\n        <area\n          key={area._id || index}\n          shape={area.shape}\n          coords={scaledCoords.join(\",\")}\n          onMouseEnter={this.hoverOn.bind(this, extendedArea, index)}\n          onMouseLeave={this.hoverOff.bind(this, extendedArea, index)}\n          onMouseMove={this.mouseMove.bind(this, extendedArea, index)}\n          onClick={this.click.bind(this, extendedArea, index)}\n          href={area.href}\n          alt={area.alt}\n        />\n      )\n    })\n  }\n\n  render() {\n    return (\n      <div style={this.styles.container} ref={node => (this.container = node)}>\n        <img\n          style={this.styles.img}\n          src={this.props.src}\n          useMap={`#${this.state.map.name}`}\n          alt=\"\"\n          ref={node => (this.img = node)}\n          onLoad={this.initCanvas}\n          onClick={this.imageClick.bind(this)}\n          onMouseMove={this.imageMouseMove.bind(this)}\n        />\n        <canvas ref={node => (this.canvas = node)} style={this.styles.canvas} />\n        <map name={this.state.map.name} style={this.styles.map}>\n          {this.renderAreas()}\n        </map>\n      </div>\n    )\n  }\n}\n\nImageMapper.defaultProps = {\n  active: true,\n  fillColor: \"rgba(255, 255, 255, 0.5)\",\n  lineWidth: 1,\n  map: {\n    areas: [],\n    name: \"image-map-\" + Math.random(),\n  },\n  strokeColor: \"rgba(0, 0, 0, 0.5)\",\n}\n\nImageMapper.propTypes = {\n  active: PropTypes.bool,\n  fillColor: PropTypes.string,\n  height: PropTypes.number,\n  imgWidth: PropTypes.number,\n  lineWidth: PropTypes.number,\n  src: PropTypes.string.isRequired,\n  strokeColor: PropTypes.string,\n  width: PropTypes.number,\n\n  onClick: PropTypes.func,\n  onMouseMove: PropTypes.func,\n  onImageClick: PropTypes.func,\n  onImageMouseMove: PropTypes.func,\n  onLoad: PropTypes.func,\n  onMouseEnter: PropTypes.func,\n  onMouseLeave: PropTypes.func,\n\n  map: PropTypes.shape({\n    areas: PropTypes.arrayOf(\n      PropTypes.shape({\n        area: PropTypes.shape({\n          coords: PropTypes.arrayOf(PropTypes.number),\n          href: PropTypes.string,\n          shape: PropTypes.string,\n          preFillColor: PropTypes.string,\n          fillColor: PropTypes.string,\n        }),\n      })\n    ),\n    name: PropTypes.string,\n  }),\n}\n"],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AAWA;AAmJA;AA0BA;;AAxLA;;;;;A","sourceRoot":""}